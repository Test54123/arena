<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Arena</title>

  <style>
    /* ===============================
       GAMEBOY 2-COLOR THEME
       =============================== */
    :root{
      --gb-dark:#0f380f;
      --gb-light:#9bbc0f;
      --gb-mid:#7ea10a;
      --a-accent: rgba(15,56,15,1);
      --b-accent: rgba(155,188,15,1);
    }

    *{ box-sizing:border-box; }
    body{
      font-family: monospace;
      background: var(--gb-light);
      color: var(--gb-dark);
      padding:14px;
      margin:0;
    }

    .wrap{ max-width: 980px; margin: 0 auto; }
    h2{ margin: 6px 0 12px; }

    .card{
      background: rgba(155,188,15,0.55);
      border:3px solid var(--gb-dark);
      border-radius:12px;
      padding:12px;
      margin-bottom:14px;
    }

    label{ display:block; margin-top:8px; }
    input,select,button{
      width:100%;
      padding:10px;
      margin-top:6px;
      border-radius:10px;
      border:2px solid var(--gb-dark);
      font-size:16px;
      background: var(--gb-light);
      color: var(--gb-dark);
    }

    button{ cursor:pointer; font-weight:bold; }
    button:disabled{ opacity:0.4; cursor:not-allowed; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .row > *{ flex:1; min-width: 140px; }

    .pillRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .pill{
      padding:6px 10px;
      border:2px solid var(--gb-dark);
      border-radius:999px;
      background: rgba(155,188,15,0.65);
      display:inline-block;
    }

    .small{ font-size: 13px; opacity: 0.95; margin-top:8px; }

    .hintBox{
      border:2px solid rgba(15,56,15,0.6);
      border-radius:10px;
      padding:10px;
      background: rgba(155,188,15,0.30);
      margin-top:10px;
    }
    .monoSmall{ font-size: 12px; opacity: 0.95; }

    /* ===============================
       BOARD
       =============================== */
    .boardWrap{ display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; }

    .boardShell{
      display:inline-block;
      border:3px solid var(--gb-dark);
      border-radius:14px;
      padding:10px;
      background: rgba(155,188,15,0.35);
    }

    .board{
      width: 280px;
      height: 280px;
      border:3px solid var(--gb-dark);
      border-radius:10px;
      background: rgba(155,188,15,0.30);
      display:grid;
      overflow:hidden;
      position:relative;
      touch-action: manipulation;
    }

    .cell{
      border:1px solid rgba(15,56,15,0.55);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      user-select:none;
      background: rgba(155,188,15,0.18);
    }

    .corner{
      background: rgba(15,56,15,0.10);
    }

    /* ===============================
       SOLDIER SPRITE (CSS pixel-ish)
       Two "colors": A = dark silhouette,
       B = light silhouette with dark outline
       =============================== */
    .unitWrap{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }

    .unit{
      width: 28px;
      height: 32px;
      position:relative;
      image-rendering: pixelated;
    }

    /* HP bar */
    .hpbar{
      position:absolute;
      left:50%;
      top:-11px;
      transform:translateX(-50%);
      width:30px;
      height:7px;
      border:2px solid var(--gb-dark);
      background: rgba(155,188,15,0.85);
    }
    .hpfill{
      height:100%;
      background: var(--gb-dark);
      width:100%;
    }

    /* sprite parts */
    .sprite{
      position:absolute;
      left:0; top:0;
      width:100%; height:100%;
    }

    .head,.body,.arm,.leg{
      position:absolute;
      transform-origin: top center;
    }

    /* A (dark) */
    .unitA .head,
    .unitA .body,
    .unitA .arm,
    .unitA .leg{ background: var(--gb-dark); }

    /* B (light) + outline */
    .unitB .head,
    .unitB .body,
    .unitB .arm,
    .unitB .leg{
      background: var(--gb-light);
      outline: 2px solid var(--gb-dark);
      outline-offset: -2px;
    }

    .head{ left:10px; top:0px; width:8px; height:8px; }
    .body{ left:9px; top:8px; width:10px; height:10px; }

    .arm{ top:10px; width:4px; height:7px; }
    .arm.left{ left:5px; }
    .arm.right{ right:5px; }

    .leg{ top:18px; width:5px; height:12px; }
    .leg.left{ left:8px; }
    .leg.right{ right:8px; }

    /* Facing */
    .face-left  { transform: scaleX(-1); }
    .face-right { transform: scaleX(1); }
    .face-up    { transform: scaleX(1); }
    .face-down  { transform: scaleX(1); }

    /* Walking legs wiggle */
    .walk .leg.left  { animation: walkL .22s infinite alternate; }
    .walk .leg.right { animation: walkR .22s infinite alternate; }
    @keyframes walkL{ from{ transform:rotate(18deg);} to{ transform:rotate(-18deg);} }
    @keyframes walkR{ from{ transform:rotate(-18deg);} to{ transform:rotate(18deg);} }

    /* Hit flash */
    .hitFlash{ animation: hitFlash .25s 1; }
    @keyframes hitFlash{
      0%{ filter: invert(0); }
      50%{ filter: invert(1); }
      100%{ filter: invert(0); }
    }

    /* Attack slash overlay */
    .slash{
      position:absolute;
      width:36px;
      height:6px;
      background: var(--gb-dark);
      border:2px solid var(--gb-dark);
      border-radius:6px;
      opacity:0;
      animation: slashPop .22s ease-out 1;
      pointer-events:none;
    }
    @keyframes slashPop{
      0%   { opacity:0.0; transform: translate(-50%,-50%) scaleX(0.3); }
      35%  { opacity:1.0; transform: translate(-50%,-50%) scaleX(1.0); }
      100% { opacity:0.0; transform: translate(-50%,-50%) scaleX(0.6); }
    }

    /* DPAD */
    .dpad{
      display:grid;
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px;
      gap:8px;
      justify-content:center;
      margin-top:10px;
    }
    .dpad button{ height:64px; width:64px; }
    .dpad .empty{ visibility:hidden; }

    /* LOG */
    #log{
      background:black;
      color:#00ff00;
      padding:10px;
      border-radius:10px;
      min-height:180px;
      white-space:pre-wrap;
      font-size:14px;
      overflow:auto;
      border:3px solid var(--gb-dark);
    }

    .statsBox{
      border:2px dashed rgba(15,56,15,0.85);
      border-radius:10px;
      padding:10px;
      background: rgba(155,188,15,0.25);
      margin-top:10px;
    }
    .statLine{ margin:4px 0; }
  </style>
</head>

<body>
<div class="wrap">
  <h2 id="title">üè∞ Arena</h2>

  <div class="card">
    <h3 id="roomTitle">Room</h3>

    <label id="lblRoom">Room Code</label>
    <input id="room" value="ARENA"/>

    <label id="lblPass">Password</label>
    <input id="pass" value="rose"/>

    <div class="row" style="margin-top:10px;">
      <button id="btnHost" onclick="connectHost()">Host (Create)</button>
      <button id="btnSpec" onclick="connectSpectate()">Spectate</button>
    </div>

    <hr/>

    <h3 id="joinTitle">Join as Player</h3>

    <label id="lblName">Your name</label>
    <input id="myName" value="Player"/>

    <label id="lblSeat">Seat</label>
    <select id="seat">
      <option value="A">Player A</option>
      <option value="B">Player B</option>
    </select>

    <div class="hintBox">
      <b id="optA">Option A: Enter ‚ÄúPower‚Äù (like your Kingshot screenshot)</b>
      <div class="row">
        <input id="kSquad" placeholder="Squad Power (e.g. 36.846.418)" inputmode="numeric"/>
        <input id="kHero" placeholder="Hero Power (e.g. 17.030.383)" inputmode="numeric"/>
      </div>
      <div class="row">
        <input id="kBuild" placeholder="Building Power" inputmode="numeric"/>
        <input id="kTech" placeholder="Tech Power" inputmode="numeric"/>
      </div>
      <div class="row">
        <input id="kGov" placeholder="Governor Gear Power" inputmode="numeric"/>
        <input id="kPet" placeholder="Pet Power" inputmode="numeric"/>
      </div>
      <div class="row">
        <button id="btnCalc" onclick="calcFromKraft()">Power ‚Üí Stats (fills HP/ATK/DEF)</button>
      </div>

      <div class="monoSmall" id="optAhelp">
        Auto-update is ON: as you type power, HP/ATK/DEF update automatically.
        Conversion: HP from Hero (/1,000,000), ATK from Squad (/2,000,000), DEF from (Build+Tech+Gov+Pet) (/3,000,000) with limits.
      </div>

      <div class="monoSmall" style="margin-top:6px;">
        Preview: <b>HP</b> <span id="pvHp">-</span> |
        <b>ATK</b> <span id="pvAtk">-</span> |
        <b>DEF</b> <span id="pvDef">-</span> |
        <b>Total</b> <span id="pvTotal">-</span>
      </div>
    </div>

    <div class="hintBox">
      <b id="optB">Option B: Enter stats directly</b>
      <div class="row">
        <input id="hpMax" placeholder="HP Max (default 50)" inputmode="numeric"/>
        <input id="atk" placeholder="ATK (default 10)" inputmode="numeric"/>
        <input id="def" placeholder="DEF (default 5)" inputmode="numeric"/>
      </div>
      <div class="small" id="optBhelp">If power fields are filled, they are preferred.</div>
    </div>

    <button id="btnJoinSeat" onclick="joinSeat()" style="margin-top:10px;">Join Player Seat</button>

    <div class="pillRow">
      <div class="pill"><span id="lblStatus">Status</span>: <span id="status">not connected</span></div>
      <div class="pill"><span id="lblRole">Role</span>: <span id="role">-</span></div>
      <div class="pill"><span id="lblGame">Game</span>: <span id="gameLine">-</span></div>
    </div>

    <div class="small" id="helpLine">
      ‚úÖ Mobile: D-Pad below. PC: Arrow keys. <br/>
      ‚ö†Ô∏è Attack only works when you stand next to the enemy (1 tile).
    </div>
  </div>

  <div class="card">
    <h3 id="gameTitle">Game</h3>

    <div class="boardWrap">
      <div class="boardShell">
        <div class="board" id="board"></div>

        <div id="dpadWrap" style="display:none;">
          <div class="dpad">
            <button class="empty">.</button>
            <button onclick="move('up')">‚¨ÜÔ∏è</button>
            <button class="empty">.</button>

            <button onclick="move('left')">‚¨ÖÔ∏è</button>
            <button class="empty">.</button>
            <button onclick="move('right')">‚û°Ô∏è</button>

            <button class="empty">.</button>
            <button onclick="move('down')">‚¨áÔ∏è</button>
            <button class="empty">.</button>
          </div>
        </div>
      </div>

      <div style="flex:1; min-width:260px;">
        <h4 id="hostTitle">Host Controls</h4>
        <div class="row">
          <button id="btnStartReset" onclick="hostStartReset()" disabled>Start Game (Host)</button>
        </div>
        <div class="small" id="hostHint">Needs both players to join. Only host can start.</div>

        <hr/>

        <h4 id="actionsTitle">Actions (Players only)</h4>
        <div class="row">
          <button id="btnAttack" onclick="action('attack')" disabled>‚öîÔ∏è Attack</button>
          <button id="btnDefend" onclick="action('defend')" disabled>üõ°Ô∏è Defend (0/6)</button>
          <button id="btnHeal" onclick="action('heal')" disabled>‚ú® Heal (0/6)</button>
        </div>

        <div class="statsBox" id="statsBox" style="display:none;">
          <div class="statLine"><b id="meLabel">You:</b> <span id="meName">-</span></div>
          <div class="statLine">HP: <span id="meHp">-</span> / <span id="meHpMax">-</span></div>
          <div class="statLine">ATK: <span id="meAtk">-</span> | DEF: <span id="meDef">-</span></div>
          <div class="statLine">Pos: (<span id="meX">-</span>, <span id="meY">-</span>)</div>
          <div class="statLine"><b>Total Power:</b> <span id="meKTotal">-</span></div>
        </div>

        <div class="statsBox" id="oppBox" style="display:none;">
          <div class="statLine"><b id="oppLabel">Enemy:</b> <span id="opName">-</span></div>
          <div class="statLine">HP: <span id="opHp">-</span> / <span id="opHpMax">-</span></div>
          <div class="statLine">ATK: <span id="opAtk">-</span> | DEF: <span id="opDef">-</span></div>
          <div class="statLine">Pos: (<span id="opX">-</span>, <span id="opY">-</span>)</div>
          <div class="statLine"><b>Total Power:</b> <span id="opKTotal">-</span></div>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3 id="logTitle">Battle Log</h3>
    <div id="log">Not connected.</div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();

  // language: German if browser starts with "de", else English
  const LANG = (navigator.language || "").toLowerCase().startsWith("de") ? "de" : "en";

  const I18N = {
    de: {
      room:"Room", roomCode:"Room Code", pass:"Password",
      host:"Host (Create)", spec:"Spectate",
      join:"Als Spieler beitreten", yourName:"Dein Name", seat:"Seat",
      status:"Status", role:"Rolle", game:"Spiel",
      help:"‚úÖ Handy: D-Pad unten. PC: Pfeiltasten.<br/>‚ö†Ô∏è Attack geht nur, wenn du direkt neben dem Gegner stehst (1 Feld).",
      hostControls:"Host Controls", needsBoth:"Braucht Player A & B. Nur der Host kann starten.",
      actions:"Aktionen (nur Spieler)",
      you:"Du:", enemy:"Gegner:",
      notConn:"nicht verbunden",
      notStarted:"nicht gestartet",
      startHost:"Start Game (Host)",
      resetHost:"Reset Game (Host)",
      running:"l√§uft",
      connected:"verbunden",
      optA:"Option A: Kraft eingeben (wie im Screenshot)",
      optB:"Option B: Werte direkt eingeben",
      optAhelp:"Auto-Update ist AN: beim Tippen aktualisieren sich HP/ATK/DEF. Umrechnung: HP aus Held (/1.000.000), ATK aus Schwadron (/2.000.000), DEF aus (Geb√§ude+Tech+Gov+Pet) (/3.000.000) mit Limits.",
      optBhelp:"Wenn Kraft-Felder ausgef√ºllt sind, werden sie bevorzugt genutzt.",
      btnCalc:"Kraft ‚Üí Stats (f√ºllt HP/ATK/DEF)"
    },
    en: {
      room:"Room", roomCode:"Room Code", pass:"Password",
      host:"Host (Create)", spec:"Spectate",
      join:"Join as Player", yourName:"Your name", seat:"Seat",
      status:"Status", role:"Role", game:"Game",
      help:"‚úÖ Mobile: D-Pad below. PC: Arrow keys.<br/>‚ö†Ô∏è Attack only works when you stand next to the enemy (1 tile).",
      hostControls:"Host Controls", needsBoth:"Needs Player A & B. Only host can start.",
      actions:"Actions (Players only)",
      you:"You:", enemy:"Enemy:",
      notConn:"not connected",
      notStarted:"not started",
      startHost:"Start Game (Host)",
      resetHost:"Reset Game (Host)",
      running:"running",
      connected:"connected",
      optA:"Option A: Enter ‚ÄúPower‚Äù (like your screenshot)",
      optB:"Option B: Enter stats directly",
      optAhelp:"Auto-update is ON: as you type power, HP/ATK/DEF update automatically. Conversion: HP from Hero (/1,000,000), ATK from Squad (/2,000,000), DEF from (Build+Tech+Gov+Pet) (/3,000,000) with limits.",
      optBhelp:"If power fields are filled, they are preferred.",
      btnCalc:"Power ‚Üí Stats (fills HP/ATK/DEF)"
    }
  };
  function t(k){ return I18N[LANG][k] || k; }

  // ---------- UI helpers ----------
  function $(id){ return document.getElementById(id); }
  function setStatus(txt){ $("status").textContent = txt; }
  function setLog(lines){
    const box = $("log");
    box.textContent = (lines && lines.length) ? lines.join("\n") : "";
    box.scrollTop = box.scrollHeight;
  }

  // Apply i18n labels
  (function applyI18n(){
    $("roomTitle").textContent = t("room");
    $("lblRoom").textContent = t("roomCode");
    $("lblPass").textContent = t("pass");
    $("btnHost").textContent = t("host");
    $("btnSpec").textContent = t("spec");
    $("joinTitle").textContent = t("join");
    $("lblName").textContent = t("yourName");
    $("lblSeat").textContent = t("seat");
    $("lblStatus").textContent = t("status");
    $("lblRole").textContent = t("role");
    $("lblGame").textContent = t("game");
    $("helpLine").innerHTML = t("help");
    $("hostTitle").textContent = t("hostControls");
    $("hostHint").textContent = t("needsBoth");
    $("actionsTitle").textContent = t("actions");
    $("meLabel").textContent = t("you");
    $("oppLabel").textContent = t("enemy");
    $("optA").textContent = t("optA");
    $("optB").textContent = t("optB");
    $("optAhelp").textContent = t("optAhelp");
    $("optBhelp").textContent = t("optBhelp");
    $("btnCalc").textContent = t("btnCalc");
  })();

  // ---------- state ----------
  let currentRoom = null;
  let currentRole = "-"; // host | player | spectator
  let currentSeat = null; // A | B | null
  let lastState = null;

  // animation memory
  const lastPos = { A:null, B:null };
  const lastHp  = { A:null, B:null };
  const lastDir = { A:"down", B:"up" };
  const walkingUntil = { A:0, B:0 };
  const hitUntil = { A:0, B:0 };

  function roomVal(){ return $("room").value.trim().toUpperCase(); }
  function passVal(){ return $("pass").value.trim(); }

  // ---------- Kraft -> Stats (client) ----------
  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
  function parseDEInt(v){
    if(!v) return 0;
    const s = String(v).replace(/\./g,'').replace(/\s/g,'').trim();
    const x = parseInt(s, 10);
    return Number.isFinite(x) ? x : 0;
  }
  function kraftObj(){
    return {
      squad: $("kSquad").value,
      build: $("kBuild").value,
      tech:  $("kTech").value,
      gov:   $("kGov").value,
      hero:  $("kHero").value,
      pet:   $("kPet").value,
    };
  }
  function kraftTotal(k){
    return parseDEInt(k.squad) + parseDEInt(k.build) + parseDEInt(k.tech) + parseDEInt(k.gov) + parseDEInt(k.hero) + parseDEInt(k.pet);
  }
  function kraftToStats(k){
    const squad = parseDEInt(k.squad);
    const build = parseDEInt(k.build);
    const tech  = parseDEInt(k.tech);
    const gov   = parseDEInt(k.gov);
    const hero  = parseDEInt(k.hero);
    const pet   = parseDEInt(k.pet);

    const hpMax = clamp(50 + Math.round(hero / 1_000_000), 10, 200);
    const atk   = clamp(10 + Math.round(squad / 2_000_000), 1, 50);
    const defPool = build + tech + gov + pet;
    const def   = clamp(5 + Math.round(defPool / 3_000_000), 0, 50);

    return { hpMax, atk, def };
  }
  function anyKraftFilled(){
    return Object.values(kraftObj()).some(v => String(v||"").trim() !== "");
  }
  function updateKraftPreviewAndStats(){
    const k = kraftObj();
    const has = anyKraftFilled();
    if (!has){
      $("pvHp").textContent = "-";
      $("pvAtk").textContent = "-";
      $("pvDef").textContent = "-";
      $("pvTotal").textContent = "-";
      return;
    }
    const s = kraftToStats(k);
    $("pvHp").textContent = s.hpMax;
    $("pvAtk").textContent = s.atk;
    $("pvDef").textContent = s.def;
    $("pvTotal").textContent = kraftTotal(k).toLocaleString(LANG==="de"?"de-DE":"en-US");

    $("hpMax").value = String(s.hpMax);
    $("atk").value = String(s.atk);
    $("def").value = String(s.def);
  }
  function calcFromKraft(){
    updateKraftPreviewAndStats();
    const lines = ($("log").textContent || "").split("\n").filter(Boolean);
    if (anyKraftFilled()){
      lines.push(`üßÆ Power‚ÜíStats: HP ${$("hpMax").value} | ATK ${$("atk").value} | DEF ${$("def").value}`);
      lines.push(`üìä Total: ${$("pvTotal").textContent}`);
    } else {
      lines.push("‚ö†Ô∏è No power entered.");
    }
    setLog(lines);
  }
  window.addEventListener("load", () => {
    ["kSquad","kBuild","kTech","kGov","kHero","kPet"].forEach(id=>{
      const el = $(id);
      el.addEventListener("input", updateKraftPreviewAndStats);
      el.addEventListener("change", updateKraftPreviewAndStats);
    });
    updateKraftPreviewAndStats();
  });

  // ---------- connect/join ----------
  function connectHost(){
    socket.emit("hostRoom", { room: roomVal(), pass: passVal() });
  }
  function connectSpectate(){
    socket.emit("spectateRoom", { room: roomVal(), pass: passVal() });
  }
  function joinSeat(){
    const room = roomVal();
    const pass = passVal();
    const seat = $("seat").value;
    const name = ($("myName").value || "").trim();

    let stats;
    const k = kraftObj();

    if (anyKraftFilled()){
      const s = kraftToStats(k);
      stats = {
        hpMax: String(s.hpMax),
        atk: String(s.atk),
        def: String(s.def),
        kraft: k,
      };
      $("hpMax").value = String(s.hpMax);
      $("atk").value = String(s.atk);
      $("def").value = String(s.def);
    } else {
      stats = {
        hpMax: ($("hpMax").value || "").trim(),
        atk:   ($("atk").value || "").trim(),
        def:   ($("def").value || "").trim(),
        kraft: { squad:"",build:"",tech:"",gov:"",hero:"",pet:"" },
      };
    }

    socket.emit("joinSeat", { room, pass, seat, name, stats });
  }

  function hostStartReset(){
    const action = (lastState && lastState.started) ? "reset" : "start";
    socket.emit("hostStartReset", { room: roomVal(), pass: passVal(), action });
  }

  function move(dir){
    if (!currentRoom) return;
    if (currentRole !== "player") return;
    socket.emit("move", { room: currentRoom, pass: passVal(), dir });
  }

  function action(type){
    if (!currentRoom) return;
    if (currentRole !== "player") return;
    socket.emit("action", { room: currentRoom, pass: passVal(), type });
  }

  // keyboard
  window.addEventListener("keydown", (e) => {
    if (currentRole !== "player") return;
    if (e.key === "ArrowUp") move("up");
    if (e.key === "ArrowDown") move("down");
    if (e.key === "ArrowLeft") move("left");
    if (e.key === "ArrowRight") move("right");
  });

  // ---------- UI enable/disable ----------
  function setRoleText(){
    if (currentRole === "player") $("role").textContent = "player " + currentSeat;
    else $("role").textContent = currentRole || "-";
  }
  function updateUI(){
    $("btnStartReset").disabled = (currentRole !== "host");
    const isPlayer = (currentRole === "player");
    $("btnAttack").disabled = !isPlayer;
    $("btnDefend").disabled = !isPlayer;
    $("btnHeal").disabled = !isPlayer;
    $("dpadWrap").style.display = isPlayer ? "block" : "none";
    $("statsBox").style.display = isPlayer ? "block" : "none";
    $("oppBox").style.display = isPlayer ? "block" : "none";
  }

  // ---------- direction helpers ----------
  function dirFromDelta(prev, cur){
    if (!prev || !cur) return null;
    if (cur.x > prev.x) return "right";
    if (cur.x < prev.x) return "left";
    if (cur.y > prev.y) return "down";
    if (cur.y < prev.y) return "up";
    return null;
  }
  function faceClass(dir){
    if (dir === "left") return "face-left";
    if (dir === "right") return "face-right";
    if (dir === "up") return "face-up";
    return "face-down";
  }
  function toward(att, def){
    if (!att || !def) return null;
    const dx = def.x - att.x;
    const dy = def.y - att.y;
    if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? "right" : "left";
    return dy > 0 ? "down" : "up";
  }

  function spawnSlash(boardEl, ax, ay, bx, by, w, h){
    const rect = boardEl.getBoundingClientRect();
    const cellW = rect.width / w;
    const cellH = rect.height / h;
    const mx = (ax + bx + 1) / 2 * cellW;
    const my = (ay + by + 1) / 2 * cellH;

    const slash = document.createElement("div");
    slash.className = "slash";
    slash.style.left = `${mx}px`;
    slash.style.top  = `${my}px`;

    const dx = bx - ax;
    const dy = by - ay;
    let ang = 0;
    if (dx === 1) ang = 0;
    else if (dx === -1) ang = 180;
    else if (dy === 1) ang = 90;
    else if (dy === -1) ang = -90;
    slash.style.transform = `translate(-50%,-50%) rotate(${ang}deg)`;

    boardEl.appendChild(slash);
    setTimeout(() => slash.remove(), 260);
  }

  function makeUnitNode(seatKey, p){
    const wrap = document.createElement("div");
    wrap.className = "unitWrap";

    const unit = document.createElement("div");
    unit.className = "unit " + (seatKey === "A" ? "unitA" : "unitB");

    // HP bar
    const hpbar = document.createElement("div");
    hpbar.className = "hpbar";
    const hpfill = document.createElement("div");
    hpfill.className = "hpfill";
    const ratio = (p.hpMax > 0) ? Math.max(0, Math.min(1, p.hp / p.hpMax)) : 0;
    hpfill.style.width = `${Math.round(ratio * 100)}%`;
    hpbar.appendChild(hpfill);
    unit.appendChild(hpbar);

    const sprite = document.createElement("div");
    const dir = lastDir[seatKey] || "down";
    const walking = (Date.now() < walkingUntil[seatKey]) ? "walk" : "";
    const hit = (Date.now() < hitUntil[seatKey]) ? "hitFlash" : "";
    sprite.className = `sprite ${faceClass(dir)} ${walking} ${hit}`.trim();

    const head = document.createElement("div"); head.className="head";
    const body = document.createElement("div"); body.className="body";
    const armL = document.createElement("div"); armL.className="arm left";
    const armR = document.createElement("div"); armR.className="arm right";
    const legL = document.createElement("div"); legL.className="leg left";
    const legR = document.createElement("div"); legR.className="leg right";

    sprite.appendChild(head);
    sprite.appendChild(body);
    sprite.appendChild(armL);
    sprite.appendChild(armR);
    sprite.appendChild(legL);
    sprite.appendChild(legR);

    unit.appendChild(sprite);
    wrap.appendChild(unit);
    return wrap;
  }

  function render(st){
    updateUI();

    // Game line
    if (!st.started) {
      $("gameLine").textContent = t("notStarted");
    } else {
      const sec = Math.ceil((st.timeLeftMs || 0) / 1000);
      const mm = String(Math.floor(sec/60)).padStart(2,"0");
      const ss = String(sec%60).padStart(2,"0");
      $("gameLine").textContent = `${t("running")} (${mm}:${ss})`;
    }

    // Host button text
    if (currentRole === "host") {
      $("btnStartReset").textContent = st.started ? t("resetHost") : t("startHost");
    } else {
      $("btnStartReset").textContent = t("startHost");
    }

    setLog(st.log || []);

    const w = st.grid?.w || 4;
    const h = st.grid?.h || 4;
    const board = $("board");
    board.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
    board.style.gridTemplateRows = `repeat(${h}, 1fr)`;
    board.innerHTML = "";

    const A = st.players?.A || null;
    const B = st.players?.B || null;

    // movement detection
    [["A",A],["B",B]].forEach(([k,p])=>{
      if (!p || !p.pos) return;
      const prev = lastPos[k];
      const d = dirFromDelta(prev, p.pos);
      if (d){
        lastDir[k] = d;
        walkingUntil[k] = Date.now() + 450;
      }
      lastPos[k] = { x:p.pos.x, y:p.pos.y };
    });

    // hp delta detection -> flash + slash + attacker facing
    if (A && B && A.pos && B.pos){
      const prevA = (lastHp.A == null) ? A.hp : lastHp.A;
      const prevB = (lastHp.B == null) ? B.hp : lastHp.B;

      const aLost = Math.max(0, prevA - A.hp);
      const bLost = Math.max(0, prevB - B.hp);

      if (aLost > 0 || bLost > 0){
        let defK = null, attK = null;
        if (aLost > 0 && bLost === 0){ defK="A"; attK="B"; }
        else if (bLost > 0 && aLost === 0){ defK="B"; attK="A"; }

        if (defK && attK){
          hitUntil[defK] = Date.now() + 260;
          const att = (attK==="A") ? A : B;
          const def = (defK==="A") ? A : B;

          const face = toward(att.pos, def.pos);
          if (face) lastDir[attK] = face;

          const dist = Math.abs(att.pos.x - def.pos.x) + Math.abs(att.pos.y - def.pos.y);
          if (dist === 1){
            setTimeout(()=>spawnSlash(board, att.pos.x, att.pos.y, def.pos.x, def.pos.y, w, h), 0);
          }
        } else {
          if (aLost > 0) hitUntil.A = Date.now() + 260;
          if (bLost > 0) hitUntil.B = Date.now() + 260;
        }
      }

      lastHp.A = A.hp;
      lastHp.B = B.hp;
    } else {
      if (A) lastHp.A = A.hp;
      if (B) lastHp.B = B.hp;
    }

    const corners = new Set([`0,0`, `${w-1},0`, `0,${h-1}`, `${w-1},${h-1}`]);

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const cell = document.createElement("div");
        cell.className = "cell" + (corners.has(`${x},${y}`) ? " corner" : "");

        if (A && A.pos && A.pos.x === x && A.pos.y === y){
          cell.appendChild(makeUnitNode("A", A));
        }
        if (B && B.pos && B.pos.x === x && B.pos.y === y){
          cell.appendChild(makeUnitNode("B", B));
        }
        board.appendChild(cell);
      }
    }

    // player stats panel
    if (currentRole === "player" && currentSeat && st.players && st.players[currentSeat]){
      const me = st.players[currentSeat];
      $("btnDefend").textContent = `üõ°Ô∏è Defend (${me.usedDefend || 0}/6)`;
      $("btnHeal").textContent = `‚ú® Heal (${me.usedHeal || 0}/6)`;
      $("btnAttack").textContent = "‚öîÔ∏è Attack";

      $("meName").textContent = me.name ?? "-";
      $("meHp").textContent = me.hp ?? "-";
      $("meHpMax").textContent = me.hpMax ?? "-";
      $("meAtk").textContent = me.atk ?? "-";
      $("meDef").textContent = me.def ?? "-";
      $("meX").textContent = me.pos?.x ?? "-";
      $("meY").textContent = me.pos?.y ?? "-";
      $("meKTotal").textContent = (me.kraft?.total ?? 0).toLocaleString(LANG==="de"?"de-DE":"en-US");

      const oppSeat = (currentSeat === "A") ? "B" : "A";
      const op = st.players[oppSeat];
      $("opName").textContent = op?.name ?? "-";
      $("opHp").textContent = op?.hp ?? "-";
      $("opHpMax").textContent = op?.hpMax ?? "-";
      $("opAtk").textContent = op?.atk ?? "-";
      $("opDef").textContent = op?.def ?? "-";
      $("opX").textContent = op?.pos?.x ?? "-";
      $("opY").textContent = op?.pos?.y ?? "-";
      $("opKTotal").textContent = (op?.kraft?.total ?? 0).toLocaleString(LANG==="de"?"de-DE":"en-US");
    } else {
      $("btnDefend").textContent = "üõ°Ô∏è Defend (0/6)";
      $("btnHeal").textContent = "‚ú® Heal (0/6)";
      $("btnAttack").textContent = "‚öîÔ∏è Attack";
    }

    // Host: enable start/reset only if both players exist
    if (currentRole === "host"){
      const both = !!(st.players?.A && st.players?.B);
      $("btnStartReset").disabled = !both;
    }
  }

  // ---------- sockets ----------
  socket.on("connect", () => {
    setStatus(t("connected"));
    setLog(["‚úÖ Connected to server!"]);
    currentRoom = null;
    currentRole = "-";
    currentSeat = null;
    setRoleText();
    updateUI();
  });

  socket.on("disconnect", () => {
    setStatus("disconnected");
  });

  socket.on("errorMsg", (m) => {
    alert(m);
    const lines = ($("log").textContent || "").split("\n").filter(Boolean);
    lines.push("‚ùå " + m);
    setLog(lines);
  });

  socket.on("role", ({ role, seat }) => {
    currentRole = role;
    currentSeat = seat || null;
    currentRoom = roomVal();
    setRoleText();
    updateUI();
    socket.emit("requestState", { room: currentRoom });
  });

  socket.on("state", (st) => {
    lastState = st;
    render(st);
  });
</script>
</body>
</html>
